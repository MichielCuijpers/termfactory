# system imports
import sys
import math
import itertools as it
from collections import namedtuple
import inspect
import pdb

# third party imports

# local imports
import reference_latex_headers as headers
from latex_defines import *
from latex_zhz import generate_z_operator, _build_first_z_term, _f_h_zR_contributions, _fbar_h_zR_contributions, _build_fifth_z_term
from latex_full_cc import generate_omega_operator, generate_full_cc_hamiltonian_operator
from common_imports import tab, z_summation_indices, z_unlinked_indices, summation_indices, old_print_wrapper
from namedtuple_defines import general_operator_namedtuple, hamiltonian_namedtuple


import log_conf

log = log_conf.get_filebased_logger('output.txt')
header_log = log_conf.HeaderAdapter(log, {})
subheader_log = log_conf.SubHeaderAdapter(log, {})
# ----------------------------------------------------------------------------------------------- #
# -------------------------  GENERATING FULL Omega e^T Z H Z symmetrized LATEX  ----------------------------- #
# ----------------------------------------------------------------------------------------------- #

eT_operator_namedtuple = namedtuple('eT_operator', ['maximum_rank', 'operator_list'])


# -------------------------------------------------------------------------------- #
def generate_eT_operator(maximum_eT_rank=2):
    """Return an `eT_operator_namedtuple` whose attributes are determined by `maximum_cc_rank`.

    The `operator_list` contains all permutations of (`m`,`n`) for `m` & `n` in `range(maximum_cc_rank + 1)`.
    The name is a string of the chars `d` and `b` according to `m` and `n` respectively.
    `m` is associated with creation operators (d) and `n` is associated with annihilation operators (b).
    """
    return_list = []

    for m in [0]:                                    # m is the upper label (creation operators)
        for n in range(0, maximum_eT_rank + 1 - m):  # n is the lower label (annihilation operators)

            # we account for the zero order S operator in `_generate_s_taylor_expansion`
            if m == n == 0:
                continue

            name = "s"
            name += f"^{m}" if m > 0 else ""
            name += f"_{n}" if n > 0 else ""

            return_list.append(general_operator_namedtuple(name, m+n, m, n))

    return eT_operator_namedtuple(maximum_eT_rank, return_list)


def generate_eT_taylor_expansion(maximum_eT_rank=2, eT_taylor_max_order=3):
    """Return a list of lists of `eT_operator_namedtuple`s.

    Expanding e^{T} by Taylor series gives you 1 + T + T^2 + T^3 ... etc.
    Each of the terms in that sum (1, T, T^2, ...) is represented by a list inside the returned list.
    So `eT_taylor_expansion[0]` is the 1 term and has a single `eT_operator_namedtuple`.
    `eT_taylor_expansion[1]` represents the `T` term and is a list of `eT_operator_namedtuple`s
    generated by `generate_eT_operator` from eT_1 all the way to eT_n as determined by `maximum_eT_rank`.
    The third list `eT_taylor_expansion[2]` is all the T^2 terms, and so on.

    For terms T^2 and higher we compute all possible products, including non unique ones.
    This means for T^3 we will compute T^1 * T^1 * T^1 three times, however later on we will remove the duplicate terms.
    The duplicate terms are used to account for multiple possible index label orders.

    Only creation operators can act on a system in the ground state, => `n` is required to be 0.
    """

    # The eT_operator_namedtuple's
    T = generate_eT_operator(maximum_eT_rank)

    # create the list
    eT_taylor_expansion = [None, ]*(eT_taylor_max_order+1)

    eT_taylor_expansion[0] = general_operator_namedtuple("1", 0, 0, 0)  # 1 term
    eT_taylor_expansion[1] = T.operator_list                            # T term

    """ We compute all combinations including non unique ones ON PURPOSE!!
    The products of T operators do not have indices mapping them to omega and H.
    Therefore T^2 * T^1 === T^1 * T^2.
    Later when we add indices, the non unique combinations will become unique,
    due to the nature of the process of assigning the indices.
    For example, if omega = b and h_{ij}:
     - T^2 * T^1 can become T^{ij} * T^{z}, which would be a disconnected term.
     - T^1 * T^2 can become T^{i} * T^{jz}, which would be a connected term.
    """
    for n in range(2, eT_taylor_max_order+1):
        eT_taylor_expansion[n] = [list(tup) for tup in it.product(T.operator_list, repeat=n)]

    return eT_taylor_expansion


# --------------------- Validating operator pairings ------------------------ #

def _z_joining_with_z_terms_eT(LHS, t_list, h, left_z, right_z):
    """Remove terms like `z^1_3 h^2` which require the z^1_3 to join with itself.

    We count the number of annihilation operators `b` and creation operators `d`
    provided for the left Z by the LHS, H and right Z operators.
    We count the number of annihilation operators `b` and creation operators `d`
    provided for the right Z by the LHS, H and left Z operators.

    If a left/right Z operator requires more `b`/`d`s than provided by the other
    operators this implies that left/right Z operator is contracting/joining with itself.
    Theoretically this doesn't exist, and therefore we reject this term.
    """
    available_b_for_both = LHS.n + h.n + sum([t.n for t in t_list])
    available_d_for_both = LHS.m + h.m + sum([t.m for t in t_list])

    available_b_for_left_z = right_z.n + available_b_for_both
    available_d_for_left_z = right_z.m + available_d_for_both

    available_b_for_right_z = left_z.n + available_b_for_both
    available_d_for_right_z = left_z.m + available_d_for_both

    required_b_for_left_z = left_z.m
    required_d_for_left_z = left_z.n

    required_b_for_right_z = right_z.m
    required_d_for_right_z = right_z.n

    if (required_b_for_left_z > available_b_for_left_z):
        return True

    if (required_d_for_left_z > available_d_for_left_z):
        return True

    if (required_b_for_right_z > available_b_for_right_z):
        return True

    if (required_d_for_right_z > available_d_for_right_z):
        return True

    return False


def _t_joining_with_t_terms_eT(omega, t_list, h, z_left, z_right):
    """Remove terms like `b h^1 t^2 t_2` which require the t^2 to join with t_2.

    We count the number of annihilation operators `b` and creation operators `d`
    provided by the Omega and H operators. Next we count the number of operators (`b`,`d`)
    required by all the t operators. If the t operators require more operators than
    Omega or H provide this implies that they would be contracting/joining with each other.
    Theoretically this doesn't exist, and therefore we reject this term.
    """
    available_d = omega.m + h.m + z_left.m + z_right.m
    available_b = omega.n + h.n + z_left.n + z_right.n

    required_b = sum([t.m for t in t_list])
    required_d = sum([t.n for t in t_list])

    if (required_b > available_b) or (required_d > available_d):
        return True

    return False


def _omega_joining_with_itself_eT(omega, t_list, h, z_left, z_right):
    """Remove terms like `bd h_0` which require Omega to join with itself.

    We already know that the number of operators is balanced, as we check
    that before calling this function. So here we check if the s or h terms have any b/d
    operators for omega to join with. If all these terms are h^0_0 and/or s^0_0 then omega
    must be joining with itself. Theoretically this doesn't exist, and therefore we reject this term.
    """

    # omega can't join with itself unless it has both creation and annihilation operators
    if (omega.m == 0) or (omega.n == 0):
        return False

    if omega.n > 0:
        if (h.m > 0) or (z_left.m > 0) or (z_right.m > 0):
            return False

        for t in t_list:
            if t.m > 0:
                return False

    if omega.m > 0:
        if (h.n > 0) or (z_left.n > 0) or (z_right.n > 0):
            return False

        for t in t_list:
            if t.n > 0:
                return False

    return True


def _h_joining_with_itself_eT(omega, t_list, h, z_left, z_right):
    """Remove terms like `h^1_1` which require h to join with itself.

    We already know that the number of operators is balanced, as we check
    that before calling this function. So here we check if the s or omega terms have any b/d
    operators for h to join with. If all these terms are o^0_0 and/or s^0_0 then h
    must be joining with itself. Theoretically this doesn't exist, and therefore we reject this term.
    """

    # h can't join with itself unless it has both creation and annihilation operators
    if (h.m == 0) or (h.n == 0):
        return False

    if h.n > 0:
        if (omega.m > 0) or (z_left.m > 0) or (z_right.m > 0):
            return False

        for t in t_list:
            if t.m > 0:
                return False

    if h.m > 0:
        if (omega.n > 0) or (z_left.n > 0) or (z_right.n > 0):
            return False

        for t in t_list:
            if t.n > 0:
                return False

    return True


# -------------------------------------------------------------------------------- #
# the `m_t` and `n_t` are lists of integers whose length is == number of t's
# so LHS^2_1 z_1 h^1 z_1 would mean m_l = [1, ] and m_r = [1, ] and n_h = [1, ]
connected_eT_lhs_operator_namedtuple = namedtuple(
    'connected_LHS',
    ['rank', 'm', 'n', 'm_l', 'n_l', 'm_t', 'n_t', 'm_h', 'n_h', 'm_r', 'n_r']
)
connected_eT_h_z_operator_namedtuple = namedtuple(
    'connected_h_z',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_t', 'n_t', 'm_l', 'n_l', 'm_r', 'n_r']
)
# ------------------------------------------------------------------------ #
connected_eT_z_left_operator_namedtuple = namedtuple(
    'connected_z_left',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_t', 'n_t', 'm_h', 'n_h', 'm_r', 'n_r']
)
connected_eT_z_right_operator_namedtuple = namedtuple(
    'connected_z_right',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_t', 'n_t', 'm_h', 'n_h', 'm_l', 'n_l']
)
connected_t_operator_namedtuple = namedtuple(
    'connected_t',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_l', 'n_l', 'm_h', 'n_h', 'm_r', 'n_r']
)
# ------------------------------------------------------------------------ #
disconnected_eT_z_left_operator_namedtuple = namedtuple(
    'disconnected_z_left',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_t', 'n_t', 'm_h', 'n_h', 'm_r', 'n_r']
)
disconnected_eT_z_right_operator_namedtuple = namedtuple(
    'disconnected_z_right',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_t', 'n_t', 'm_h', 'n_h', 'm_l', 'n_l']
)
disconnected_t_operator_namedtuple = namedtuple(
    'disconnected_t',
    ['rank', 'm', 'n', 'm_lhs', 'n_lhs', 'm_l', 'n_l', 'm_h', 'n_h', 'm_r', 'n_r']
)
# -------------------------------------------------------------------------------- #


def _generate_valid_eT_z_n_operator_permutations(LHS, eT, h, all_z_permutations):
    """ Remove s permutations whose b/d operators don't add up (theoretically can't exist)
    For example LHS^1 h_1 is allowed but not LHS^1 h_1 t^1 because we have 2 d operators but only 1 b operator.
    Additionally we need to make sure the t operators are not joining with themselves.
    This means that the b/d operators from Omega/LHS and h need to be sufficient to balance the b/d's from the t's.
    So LHS^1_1, h_2, t^1_1, t^2 is allowed but not LHS_1, h_1, t^1_1, t^2 because the t^1_1 term has to pair with the
    t^2, or in other words the only sources of d operators are t terms so the b operator from t^1_1 has to pair with
    a d from a t term. This is not allowed.
    """

    valid_permutations = []

    log.info(f"\n{tab}eT=" + f'\n{tab}{tab}'.join(['']+[str(t) for t in eT]))
    # generate all the possible valid permutations
    for perm_T in eT:
        subheader_log.info(f"{perm_T = }")
        for perm_Z in all_z_permutations:
            left_z, right_z = perm_Z

            str_group = f'\n{tab}'.join([
                '',
                f'{"LHS":<12s}{LHS}',
                f'{"T":<12s}{perm_T}',
                f'{"Z_left":<12s}{left_z}',
                f'{"h":<12s}{h}',
                f'{"Z_right":<12s}{right_z}',
            ])

            nof_creation_ops = LHS.m + h.m + left_z.m + right_z.m + sum([t.m for t in perm_T])
            nof_annhiliation_ops = LHS.n + h.n + left_z.n + right_z.n + sum([t.n for t in perm_T])
            cannot_pair_off_b_d_operators = bool(nof_creation_ops != nof_annhiliation_ops)

            # only terms which can pair off all operators are non zero
            if cannot_pair_off_b_d_operators:
                log.debug(f'Bad Permutation (b={nof_creation_ops} and d={nof_annhiliation_ops} are not balanced)' + str_group)
                continue

            # Omega/LHS and H need to satisfy all b/d requirements of the z terms
            # z terms can join with each other, but a single z term should not be able to join to itself!!
            if _z_joining_with_z_terms_eT(LHS, perm_T, h, left_z, right_z):
                log.debug('Bad Permutation (z joins with itself)' + str_group)
                continue

            # Omega/LHS and H need to satisfy all b/d requirements of the t terms
            # t terms can join with each other, but a single t term should not be able to join to itself!!
            if _t_joining_with_t_terms_eT(LHS, perm_T, h, left_z, right_z):
                log.debug('Bad Permutation (t joins with itself)' + str_group)
                continue

            # Omega/LHS must be able to connect with at least 1 b/d operator from h or a z_term otherwise it 'joins' with itself
            if _omega_joining_with_itself_eT(LHS, perm_T, h, left_z, right_z):
                log.debug('Bad Permutation (LHS joins with itself)' + str_group)
                continue

            # h must connect with at least 1 b/d operator from Omega/LHS or a z_term otherwise it 'joins' with itself
            if _h_joining_with_itself_eT(LHS, perm_T, h, left_z, right_z):
                log.debug('Bad Permutation (h joins with itself)' + str_group)
                continue

            if len(perm_T) == 1:
                # record a valid permutation
                log.debug('Good Permutation' + str_group)
                valid_permutations.append((tuple(perm_T), left_z, right_z))
            else:
                # record a valid permutation
                log.debug('Good Permutation' + str_group)
                valid_permutations.append((tuple(perm_T), left_z, right_z))

    return valid_permutations


def _generate_all_valid_eT_z_connection_permutations(LHS, t_list, h, left_z, right_z, log_invalid=True):
    """ Generate all possible valid combinations of z terms
    with LHS, t_list, and h over all index distributions.
    By convention the tuples are (lhs, eT, h, other_z).
    First we generate lists of all possible permutations whose sum is < the respective power (m/n)
    For example if left_z has m=4, n=2 then we generate an m_list
    which can be [0,0,0,0], [0,4,0,0], [1,1,1,1] but not things like [0,0,5,0] [2,1,1,1] etc..
    and the n_list would be [0,0,0,0], [0,0,0,2], [0,1,0,1] but not things like [1,1,1,0] [3,0,0,0] etc..
    """

    valid_upper_perm_combinations = []
    valid_lower_perm_combinations = []

    m_perms, n_perms = [], []

    # we need to dynamically adjust the temporary lists if we add more t terms
    nof_t_terms = len(t_list)

    """ generate all possible individual t assignments

    Here `a` represents LHS and `b` represents h so that we don't clobber the argument
    definitions for the top function
    """
    for s_term in [left_z, right_z]:
        M, N = s_term.m, s_term.n

        temp_list = []
        for a, b, *t in it.product(range(M+1), repeat=2+nof_t_terms):
            total = a+b+sum(t)
            if total <= M:
                temp_list.append((a, tuple(t), b, M-total))

        m_perms.append(temp_list)

        temp_list = []
        for a, b, *t in it.product(range(N+1), repeat=2+nof_t_terms):
            total = a+b+sum(t)
            if total <= N:
                temp_list.append((a, tuple(t), b, N-total))

        n_perms.append(temp_list)

    expander = lambda lst: f" {lst}" if len(lst) < 2 else ''.join([f'\n{tab}{tab}{m}' for m in lst])
    log.debug(''.join([
        "Uncombined permutations:",
        f"\n{tab}Z_left M perms:{expander(m_perms[0])}",
        f"\n{tab}Z_left N perms:{expander(n_perms[0])}",
        f"\n{tab}Z_right M perms:{expander(m_perms[1])}",
        f"\n{tab}Z_right N perms:{expander(n_perms[1])}",
    ]))

    # validate upper pairing
    combined_m_perms = list(it.product(*m_perms))
    for m_perm in combined_m_perms:
        # and `m_perm` is [Z_left, Z_right]
        left_m_perm, right_m_perm = m_perm
        # where each Z is [LHS, t_list, h, other_Z]
        # with numbers: [0, [0, ...], 0, 0]

        total_lhs_m = sum([t[0] for t in m_perm])
        total_eT_m = sum([sum(t[1]) for t in m_perm])
        total_h_m = sum([t[2] for t in m_perm])

        total_lhs_balanced = bool(total_lhs_m <= LHS.n)
        total_eT_balanced = bool(total_eT_m <= sum([t.n for t in t_list]))
        total_h_balanced = bool(total_h_m <= h.n)
        left_z_balanced_right = bool(left_m_perm[-1] <= right_z.n)
        right_z_balanced_left = bool(right_m_perm[-1] <= left_z.n)

        each_eT_balanced = all([
            bool(t.n <= (LHS.m + h.m + left_m_perm[1][i] + right_m_perm[1][i]))
            and
            bool(t.rank >= (left_m_perm[1][i] + right_m_perm[1][i]))
            for i, t in enumerate(t_list)
        ])

        print(f"{each_eT_balanced=}")
        print([(t.n, LHS.m, h.m, left_m_perm[1][i], right_m_perm[1][i]) for i, t in enumerate(t_list)])
        # pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

        dense_output = f"\n{tab}".join([
            '',
            f"{'Z_left  perm '}{left_m_perm}",
            f"{'Z_right perm '}{right_m_perm}",
            f"{'LHS':<4}{total_lhs_m:>2d} <= {LHS.n:>2d}  {total_lhs_balanced}",
            f"{'eT':<4}{total_eT_m:>2d} <= {sum([t.n for t in t_list]):>2d}  {total_eT_balanced}",
            f"{each_eT_balanced=}",
            f"{'h':<4}{total_h_m:>2d} <= {h.n:>2d}  {total_h_balanced}",
            f"{'zL':<4}{left_m_perm[-1]:>2d} <= {right_z.n:>2d}  {left_z_balanced_right}",
            f"{'zR':<4}{right_m_perm[-1]:>2d} <= {left_z.n:>2d}  {right_z_balanced_left}",
        ])

        bool_list = [
            total_h_balanced,
            total_lhs_balanced,
            total_eT_balanced,
            each_eT_balanced,
            left_z_balanced_right,
            right_z_balanced_left
        ]

        if all(bool_list):
            log.debug("  Valid upper perm" + dense_output)
            valid_upper_perm_combinations.append(m_perm)

        elif log_invalid:
            log.debug("Invalid upper perm" + dense_output)

    # validate lower pairing
    combined_n_perms = list(it.product(*n_perms))
    for n_perm in combined_n_perms:
        # and `n_perm` is [Z_left, Z_right]
        left_n_perm, right_n_perm = m_perm
        # where each Z is [LHS, t_list, h, other_Z]
        # with numbers: [0, [0, ...], 0, 0]

        total_lhs_n = sum([t[0] for t in n_perm])
        total_eT_n = sum([sum(t[1]) for t in n_perm])
        total_h_n = sum([t[2] for t in n_perm])

        total_lhs_balanced = bool(total_lhs_n <= LHS.m)
        total_eT_balanced = bool(total_eT_n <= sum([t.m for t in t_list]))
        total_h_balanced = bool(total_h_n <= h.m)
        left_z_balanced_right = bool(left_n_perm[-1] <= right_z.m)
        right_z_balanced_left = bool(right_n_perm[-1] <= left_z.m)

        each_eT_balanced = all([
            bool(t.m <= (LHS.n + h.n + left_n_perm[1][i] + right_n_perm[1][i]))
            and
            bool(t.rank >= (left_n_perm[1][i] + right_n_perm[1][i]))
            for i, t in enumerate(t_list)
        ])

        dense_output = f"\n{tab}".join([
            '',
            f"{'Z_left  perm '}{left_n_perm}",
            f"{'Z_right perm '}{right_n_perm}",
            f"{'LHS':<4}{total_lhs_n:>2d} <= {LHS.m:>2d}  {total_lhs_balanced}",
            f"{'eT':<4}{total_eT_n:>2d} <= {sum([t.m for t in t_list]):>2d}  {total_eT_balanced}",
            f"{each_eT_balanced=}",
            f"{'h':<4}{total_h_n:>2d} <= {h.m:>2d}  {total_h_balanced}",
            f"{'zL':<4}{left_n_perm[-1]:>2d} <= {right_z.m:>2d}  {left_z_balanced_right}",
            f"{'zR':<4}{right_n_perm[-1]:>2d} <= {left_z.m:>2d}  {right_z_balanced_left}",
        ])

        bool_list = [
            total_h_balanced,
            total_lhs_balanced,
            total_eT_balanced,
            each_eT_balanced,
            left_z_balanced_right,
            right_z_balanced_left
        ]

        if all(bool_list):
            log.debug("  Valid lower perm" + dense_output)
            valid_lower_perm_combinations.append(n_perm)

        elif log_invalid:
            log.debug("Invalid lower perm" + dense_output)

    return valid_upper_perm_combinations, valid_lower_perm_combinations


def _generate_all_valid_eT_connection_permutations(LHS, t_list, h, z_pair, log_invalid=True):
    """ Generate all possible valid combinations of t terms
    with LHS, z_left, h, and z_right over all index distributions.
    By convention the tuples are (lhs, eT, h, other_z).
    """

    z_left, z_right = z_pair

    if z_left is None:
        args = [0, 0, 0, 0, 0, [0, ]*len(t_list), [0, ]*len(t_list), 0, 0, 0, 0]
        z_left = disconnected_eT_z_left_operator_namedtuple(*args)

    if z_right is None:
        args = [0, 0, 0, 0, 0, [0, ]*len(t_list), [0, ]*len(t_list), 0, 0, 0, 0]
        z_right = disconnected_eT_z_right_operator_namedtuple(*args)

    valid_upper_perm_combinations = []
    valid_lower_perm_combinations = []
    m_perms, n_perms = [], []

    remaining_m = sum([t.m for t in t_list])
    remaining_m -= sum(z_left.n_t)
    remaining_m -= sum(z_right.n_t)

    remaining_n = sum([t.n for t in t_list])
    remaining_n -= sum(z_left.m_t)
    remaining_n -= sum(z_right.m_t)

    print('\nKK', remaining_m, remaining_n, t_list)

    if remaining_n == remaining_m == 0:

        temp_upper, temp_lower = [], []
        print('VV1', z_left.n_t, z_right.n_t)
        print('VV2', z_left.m_t, z_right.m_t)
        # print(z_left)
        # print(z_right)
        # print(t_list)

        for i, t in enumerate(t_list):
            temp_upper.append([0, z_left.n_t[i], 0, z_right.n_t[i]])
            temp_lower.append([0, z_left.m_t[i], 0, z_right.m_t[i]])

        valid_upper_perm_combinations.append(temp_upper)
        valid_lower_perm_combinations.append(temp_lower)

    elif remaining_m == 0:
        print(f"\n{remaining_n=}")
        print(t_list)

        # ----------------------------------------------------------
        for i, t in enumerate(t_list):
            M = t.m - z_left.n_t[i] - z_right.n_t[i]
            N = t.n - z_left.m_t[i] - z_right.m_t[i]

            temp_list = []
            print(f"{M=} {N=}")
            for a in range(M+1):
                temp_list.append((a, z_left.n_t[i], M-a, z_right.n_t[i]))

            m_perms.append(temp_list)

            temp_list = []
            for a in range(N+1):
                temp_list.append((a, z_left.m_t[i], N-a, z_right.m_t[i]))

            n_perms.append(temp_list)

        print(f"original {n_perms=}")
        # ----------------------------------------------------------
        combined_n_perms = list(it.product(*n_perms))
        for n_perm in combined_n_perms:
            print(f"{n_perm=}")

            total_lhs_n = sum([t[0] for t in n_perm])
            total_h_n = sum([t[2] for t in n_perm])

            total_lhs_balanced = bool(total_lhs_n <= LHS.m)
            total_h_balanced = bool(total_h_n <= h.m)

            dense_output = f"\n{tab}".join([
                '',
                f"{'LHS':<4}{total_lhs_n:>2d} >= {LHS.m:>2d}  {total_lhs_balanced}",
                f"{'h':<4}{total_h_n:>2d} >= {h.m:>2d}  {total_h_balanced}",
                f"{'T':<4}{n_perm}",
                f"{'zL':<4}{z_left}",
                f"{'zR':<4}{z_right}",
            ])

            if total_h_balanced and total_lhs_balanced:
                log.debug("  Valid lower perm" + dense_output)
                valid_lower_perm_combinations.append(n_perm)

            elif log_invalid:
                log.debug("Invalid lower perm" + dense_output)

        print(f"original {m_perms=}")
        # ----------------------------------------------------------
        combined_m_perms = list(it.product(*m_perms))
        for m_perm in combined_m_perms:
            print(f"{m_perm=}")

            total_lhs_m = sum([t[0] for t in m_perm])
            total_h_m = sum([t[2] for t in m_perm])

            total_lhs_balanced = bool(total_lhs_m <= LHS.n)
            total_h_balanced = bool(total_h_m <= h.n)

            dense_output = f"\n{tab}".join([
                '',
                f"{'LHS':<4}{total_lhs_m:>2d} >= {LHS.n:>2d}  {total_lhs_balanced}",
                f"{'h':<4}{total_h_m:>2d} >= {h.n:>2d}  {total_h_balanced}",
                f"{'T':<4}{m_perm}",
                f"{'zL':<4}{z_left}",
                f"{'zR':<4}{z_right}",
            ])

            if total_h_balanced and total_lhs_balanced:
                log.debug("  Valid upper perm" + dense_output)
                valid_upper_perm_combinations.append(m_perm)

            elif log_invalid:
                log.debug("Invalid upper perm" + dense_output)

    elif remaining_n == 0:
        raise Exception("have not coded this yet")

    else:
        raise Exception("have not coded this yet")

    return valid_upper_perm_combinations, valid_lower_perm_combinations


def _generate_all_o_eT_h_z_connection_permutations(LHS, h, valid_permutations, found_it_bool=False):
    """ Generate all possible permutations of matching with LHS, and h for e^T and z_terms """

    annotated_permutations = []  # store output here
    annotated_z_permutations = []  # store intermediate output here

    def print_triplet(i, p):
        et_string = ''.join([
            f"{'(':<8s}",
            f'\n{tab}{tab}{tab}{tab}{tab}'.join([str(t) for t in p[0]]),
            f"\n{tab}{tab})"
        ])

        return str(
            f'\n{tab}{i+1:<4}{"eT":<4s}{et_string}'
            f'\n{tab}{tab}{"Z left":<12s}{p[1]}'
            f'\n{tab}{tab}{"Z right":<12s}{p[2]}'
        )

    log.info(f"\n{tab}valid_permutations=" + ''.join([
        print_triplet(i, p)
        for i, p in enumerate(valid_permutations)
    ]))

    for i, triplet in enumerate(valid_permutations):

        subheader_log.debug(f"PERMUTATION{i+1:>4}")
        log.debug(f"\n{tab}Processing permutation" + print_triplet(i, triplet))

        # unpack the triplet
        t_list, left_z, right_z = triplet

        upper_perms, lower_perms = _generate_all_valid_eT_z_connection_permutations(LHS, t_list, h, left_z, right_z)

        expander = lambda lst: f" {lst}" if len(lst) < 2 else ''.join([f'\n{tab}{tab}{m}' for m in lst])
        log.debug(''.join([
            f"\n{tab}Connected permutations (Z left / Z right):",
            f"\n{tab}M perms:{expander(upper_perms)}",
            f"\n{tab}N perms:{expander(lower_perms)}",
        ]))

        # compute all the permutations for z
        for upper in upper_perms:
            for lower in lower_perms:
                assert len(upper) == len(lower)

                left_z_upper, right_z_upper = upper
                left_z_lower, right_z_lower = lower
                print(f"right z   upper:{right_z_upper}   lower:{right_z_lower}")
                print(f"left  z   upper:{left_z_upper}   lower:{left_z_lower}")
                z_left_kwargs, z_right_kwargs = {}, {}
                z_pair_list = []

                # for each Z operator we make a `connected_namedtuple` or a `disconnected_namedtuple`
                if left_z.name is None:
                    # make sure this permutation is okay for no z left
                    assert left_z_upper == left_z_lower
                    assert left_z_upper[0] == 0 and left_z_upper[2:] == (0, 0)
                    assert all([x == 0 for x in left_z_upper[1]])
                    z_pair_list.append(None)
                else:
                    z_left_kwargs = {
                        'rank': left_z.rank,
                        'm': left_z.m,
                        'm_lhs': left_z_upper[0],
                        'm_t':   left_z_upper[1],
                        'm_h':   left_z_upper[2],
                        'm_r':   left_z_upper[-1],
                        'n': left_z.n,
                        'n_lhs': left_z_lower[0],
                        'n_t':   left_z_lower[1],
                        'n_h':   left_z_lower[2],
                        'n_r':   left_z_lower[-1],
                    }
                    # if the Z operator is disconnected (meaning no connections to H)
                    if z_left_kwargs['m_h'] == z_left_kwargs['n_h'] == 0:
                        z_pair_list.append(disconnected_eT_z_left_operator_namedtuple(**z_left_kwargs))
                    # if the Z operator is connected (at least 1 connection to H)
                    else:
                        z_pair_list.append(connected_eT_z_left_operator_namedtuple(**z_left_kwargs))

                if right_z.name is None:
                    # make sure this permutation is okay for no z right
                    assert right_z_upper == right_z_lower
                    assert right_z_upper[0] == 0 and right_z_upper[2:] == (0, 0)
                    assert all([x == 0 for x in right_z_upper[1]])
                    z_pair_list.append(None)
                else:
                    print('should be (2,1)', right_z_upper)
                    z_right_kwargs = {
                        'rank': right_z.rank,
                        'm': right_z.m,
                        'm_lhs': right_z_upper[0],
                        'm_t':   right_z_upper[1],
                        'm_h':   right_z_upper[2],
                        'm_l':   right_z_upper[-1],
                        'n': right_z.n,
                        'n_lhs': right_z_lower[0],
                        'n_t':   right_z_lower[1],
                        'n_h':   right_z_lower[2],
                        'n_l':   right_z_lower[-1],
                    }
                    print('z pair list    ', z_pair_list)
                    # if the Z operator is disconnected (meaning no connections to H)
                    if z_right_kwargs['m_h'] == z_right_kwargs['n_h'] == 0:
                        z_pair_list.append(disconnected_eT_z_right_operator_namedtuple(**z_right_kwargs))
                    # if the Z operator is connected (at least 1 connection to H)
                    else:
                        z_pair_list.append(connected_eT_z_right_operator_namedtuple(**z_right_kwargs))

                    print('z pair list    ', z_pair_list[-1])

                # if we have the ZHZ terms then we need to check that the Z <-> Z contractions are correct
                if (z_left_kwargs != {}) and (z_right_kwargs != {}):

                    # if these contractions are not equal
                    if z_left_kwargs['m_r'] != z_right_kwargs['n_l']:
                        term_string = f"{tab}{LHS}, {h}, {triplet}\n{tab}{z_left_kwargs=}\n{tab}{z_right_kwargs=}\n"
                        log.debug(
                            f"Invalid term (z_left.m_r({z_left_kwargs['m_r']}) != z_right.n_l({z_right_kwargs['n_l']}))\n"
                            f"{term_string}"
                        )
                        assert False
                        continue

                    # if these contractions are not equal
                    if z_left_kwargs['n_r'] != z_right_kwargs['m_l']:
                        term_string = f"{tab}{LHS}, {h}, {triplet}\n{tab}{z_left_kwargs=}\n{tab}{z_right_kwargs=}\n"
                        log.debug(
                            f"Invalid term (z_left.n_r({z_left_kwargs['n_r']}) != z_right.m_l({z_right_kwargs['m_l']}))\n"
                            f"{term_string}"
                        )
                        assert False
                        continue

                log.debug(
                    f"\n{tab}Z left  {z_pair_list[0]}"
                    f"\n{tab}Z right {z_pair_list[1]}"
                )
                annotated_z_permutations.append(tuple(z_pair_list))

        print("STATATATAT")
        for z_pair in annotated_z_permutations:
            print('should be (2,1)', z_pair[1])
            upper_perms, lower_perms = _generate_all_valid_eT_connection_permutations(LHS, t_list, h, z_pair)
            print(f"{upper_perms=}")
            print(f"{lower_perms=}")
            print('\n\n')

        for z_pair in annotated_z_permutations:
            print('t_list', t_list)
            print('z_pair', z_pair)

            # now we have to compute all the permutations for t
            if len(t_list) == 1 and t_list[0].rank == 0:
                upper_perms = [[[0, ] * 4, ], ]
                lower_perms = [[[0, ] * 4, ], ]
            else:
                upper_perms, lower_perms = _generate_all_valid_eT_connection_permutations(LHS, t_list, h, z_pair)

            # assert upper_perms != [] and lower_perms != []

            log.debug(f"{upper_perms=}")
            log.debug(f"{lower_perms=}")

            # compute all the permutations for t
            for upper in upper_perms:   # for now the upper_perms only have 1 permutation (all zeros)
                for lower in lower_perms:

                    perm_list = []
                    print('XX', upper, lower, t_list)
                    # for each t operator we make a `connected_namedtuple` or a `disconnected_namedtuple`
                    for i, t in enumerate(t_list):
                        t_upper = upper[i]
                        t_lower = lower[i]
                        print(f"{i = }   {t}   upper:{t_upper}   lower:{t_lower}")
                        assert list(t_upper) == [0, 0, 0, 0]  # for now t's can't have upper components

                        if t.m != sum(t_upper):
                            log.debug(f"Bad t perms + z perms: {t.m = } {t_upper = }")
                            raise Exception('''Code is not robust and I'm not sure what is wrong, To-Do!''')

                        if t.n != sum(t_lower):
                            log.debug(f"Bad t perms + z perms: {t.n = } {t_lower = }")
                            raise Exception('''Code is not robust and I'm not sure what is wrong, To-Do!''')

                        t_kwargs = {
                            'rank': t.rank,
                            'm': t.m,
                            'm_lhs': t_upper[0],
                            'm_l':   t_upper[1],
                            'm_h':   t_upper[2],
                            'm_r':   t_upper[-1],
                            'n': t.n,
                            'n_lhs': t_lower[0],
                            'n_l':   t_lower[1],
                            'n_h':   t_lower[2],
                            'n_r':   t_lower[-1],
                        }

                        if z_pair[0] is not None and t_kwargs['n_l'] != z_pair[0].m_t[i]:
                            raise Exception('nope')

                        if z_pair[0] is not None and t_kwargs['m_l'] != z_pair[0].n_t[i]:
                            raise Exception('nope')

                        if t_kwargs['n_r'] != z_pair[1].m_t[i]:
                            raise Exception('nope')

                        if t_kwargs['m_r'] != z_pair[1].n_t[i]:
                            raise Exception('nope')

                        # if the t operator is disconnected (meaning no connections to H)
                        if t_kwargs['m_h'] == t_kwargs['n_h'] == 0:
                            perm_list.append(disconnected_t_operator_namedtuple(**t_kwargs))
                        # if the t operator is connected (at least 1 connection to H)
                        else:
                            perm_list.append(connected_t_operator_namedtuple(**t_kwargs))

                    # after looping over t_list we append the list of operators
                    # for this specific permutation

            annotated_permutations.append((tuple(perm_list), z_pair))

        # print('A\n', annotated_permutations)
        # pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

        splitperm = lambda array: f'\n{tab}{tab}'.join(['']+[str(t) for t in array[0]])

        for perm in annotated_permutations:
            log.debug(
                f"\n{tab}Accepted Permutation ({splitperm(perm)}"
                f"\n{tab})"
                f"\n{tab}{perm[1]}"
            )

    return annotated_permutations


def _remove_duplicate_eT_z_permutations(LHS, h, eT_connection_permutations):
    """ x """
    unique_list = []
    unique_set = set()

    # print('\n\n', eT_connection_permutations)
    for i, perm in enumerate(eT_connection_permutations):
        t_tuple, z_pair = perm
        if t_tuple is not None:
            print('\n', t_tuple)
            t_tuple = list(t_tuple)
            t_tuple.sort()
            print('\n', t_tuple)
            print('\n', perm)
            perm = (tuple(t_tuple), z_pair)

        # print('\n', perm)
        # print('\n', i, t_tuple, z_pair)
        # pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None
        # a.sort()
        # a = tuple(a)

        splitperm = lambda array: f'\n{tab}{tab}'.join(['']+[str(t) for t in array[0]])

        if perm not in unique_set:
            log.debug(f"\n{tab}Added unique: ({splitperm(perm)}\n{tab})\n{tab}{perm[1]}")
            unique_list.append(perm)
            unique_set.add(perm)
        else:
            log.debug(f"\n{tab}Removed duplicate: {splitperm(perm)}\n{tab})\n{tab}{perm[1]}")
            pass

    return unique_list


def _generate_explicit_eT_z_connections(LHS, h, unique_permutations):
    """ Generate new namedtuples for LHS and h explicitly labeling how they connect with each other and t.
    We make `connected_lhs_operator_namedtuple` and `connected_h_z_operator_namedtuple`.
    The output `labeled_permutations` is a list where each element is `[new_LHS, new_eT, new_h, z_left, z_right]`.
    We also check to make sure each term is valid.
    """

    labeled_permutations = []  # store output here

    for perm in unique_permutations:
        t_list, z_pair = perm
        z_left, z_right = z_pair
        lhs_kwargs, h_kwargs = {}, {}

        assert len(perm) == 2

        # bool declarations for readability
        z_left_exists = isinstance(z_left, (connected_eT_z_left_operator_namedtuple, disconnected_eT_z_left_operator_namedtuple))
        z_right_exists = isinstance(z_right, (connected_eT_z_right_operator_namedtuple, disconnected_eT_z_right_operator_namedtuple))

        # sanity checks
        if z_left is None:
            assert z_right_exists
        elif z_right is None:
            assert z_left_exists
        else:
            assert z_right_exists
            assert z_left_exists

        lhs_kwargs = {
            'm_l': z_left.n_lhs if z_left_exists else 0,
            'n_l': z_left.m_lhs if z_left_exists else 0,
            'm_r': z_right.n_lhs if z_right_exists else 0,
            'n_r': z_right.m_lhs if z_right_exists else 0,
            'm_t': [t.n_lhs for t in t_list],
            'n_t': [t.m_lhs for t in t_list]
        }

        h_kwargs = {
            'm_l': z_left.n_h if z_left_exists else 0,
            'n_l': z_left.m_h if z_left_exists else 0,
            'm_r': z_right.n_h if z_right_exists else 0,
            'n_r': z_right.m_h if z_right_exists else 0,
            'm_t': [t.n_h for t in t_list],
            'n_t': [t.m_h for t in t_list]
        }

        lhs_kwargs.update({'rank': LHS.m + LHS.n, 'm': LHS.m, 'n': LHS.n})
        h_kwargs.update({'rank': h.m + h.n, 'm': h.m, 'n': h.n})

        # calculate the contractions as the remainder after all other contractions
        lhs_kwargs['m_h'] = lhs_kwargs['m'] - (sum(lhs_kwargs['m_t']) + lhs_kwargs['m_l'] + lhs_kwargs['m_r'])
        lhs_kwargs['n_h'] = lhs_kwargs['n'] - (sum(lhs_kwargs['n_t']) + lhs_kwargs['n_l'] + lhs_kwargs['n_r'])
        h_kwargs['m_lhs'] = h_kwargs['m'] - (sum(h_kwargs['m_t']) + h_kwargs['m_l'] + h_kwargs['m_r'])
        h_kwargs['n_lhs'] = h_kwargs['n'] - (sum(h_kwargs['n_t']) + h_kwargs['n_l'] + h_kwargs['n_r'])

        # make sure these values are not negative
        # otherwise our math went horribly wrong somewhere and we over counted?
        # the balancing math should have been already worked out before we get to this function
        assert lhs_kwargs['m_h'] >= 0 and lhs_kwargs['n_h'] >= 0
        assert h_kwargs['m_lhs'] >= 0 and h_kwargs['n_lhs'] >= 0

        # if these contractions are not equal
        if h_kwargs['m_lhs'] != lhs_kwargs['n_h']:
            term_string = f"{tab}{LHS}, {t_list}, {h}, {perm}\n{tab}{lhs_kwargs=}\n{tab}{h_kwargs=}\n"
            log.debug(f"Found an invalid term (h.m_lhs != LHS.n_h)\n{term_string}")
            continue

        # if these contractions are not equal
        elif h_kwargs['n_lhs'] != lhs_kwargs['m_h']:
            term_string = f"{tab}{LHS}, {t_list}, {h}, {perm}\n{tab}{lhs_kwargs=}\n{tab}{h_kwargs=}\n"
            log.debug(f"Found an invalid term (h.n_lhs != LHS.m_h)\n{term_string}")
            continue

        new_LHS = connected_eT_lhs_operator_namedtuple(**lhs_kwargs)
        new_h = connected_eT_h_z_operator_namedtuple(**h_kwargs)

        upper = new_LHS.m + new_h.m + sum([t.m for t in t_list]) + z_right.m
        lower = new_LHS.n + new_h.n + sum([t.n for t in t_list]) + z_right.n
        if upper != lower:
            term_string = f"{tab}{LHS}, {t_list}, {h}, {perm}\n{tab}{lhs_kwargs=}\n{tab}{h_kwargs=}\n"
            log.debug(f"Found an invalid term (unbalanced {upper}!={lower})\n{term_string}")
            continue

        labeled_permutations.append([new_LHS, t_list, new_h, z_pair])

        for p in labeled_permutations:
            old_print_wrapper('\n\np')
            for x in p:
                old_print_wrapper(x)
            old_print_wrapper('\n\n')
        # sys.exit(0)

    return labeled_permutations


# -------------------------------------------------------------------------------- #
def _simplify_full_cc_python_prefactor(numerator_list, denominator_list):
    """ x """

    # if one of the lists is empty there is no easy simplification
    if numerator_list == [] or denominator_list == []:
        return numerator_list, denominator_list

    numerator_set = set(numerator_list)
    denominator_set = set(denominator_list)

    # if the numerator and denominator do not share the same factors
    # there is no easy simplification
    if numerator_set.isdisjoint(denominator_set):
        return numerator_list, denominator_list
    else:
        intersection = numerator_set & denominator_set

    numerator_dict = dict([(key, 0) for key in numerator_set])
    for string in numerator_list:
        numerator_dict[string] += 1

    print('nnnn', numerator_dict)

    denominator_dict = dict([(key, 0) for key in denominator_set])
    for string in denominator_list:
        denominator_dict[string] += 1

    print('dddd', denominator_dict)

    for key in intersection:
        a, b = numerator_dict[key], denominator_dict[key]
        if a > b:
            denominator_dict[key] = 0
            numerator_dict[key] = a - b
        elif a < b:
            denominator_dict[key] = b - a
            numerator_dict[key] = 0
        elif a == b:
            denominator_dict[key] = 0
            numerator_dict[key] = 0

    # make updated lists
    numerator_list, denominator_list = [], []

    for k, v in numerator_dict.items():
        numerator_list.extend([k, ]*v)
    for k, v in denominator_dict.items():
        denominator_list.extend([k, ]*v)

    if len(numerator_list) > 2 or len(denominator_list) > 2:
        print('xxxx', numerator_list)
        print('yyyy', denominator_list)

    return numerator_list, denominator_list


def _build_eT_z_latex_prefactor(t_list, h, z_left, z_right, simplify_flag=True):
    """Attempt to return latex code representing appropriate prefactor term.

    All prefactors begin with 1/n! where n is the number of t amplitudes in given term.
    This comes from the prefactors of the taylor expansion of e^S = 1 + S^1 + S^2 ....
    We also need to account for the prefactors of the Hamiltonian as defined in the theory.
    There are also permutations of indices to take into account.
    Overall the entire affair is quite complicated.

    In general the rules are:
        - 1/n! where n is the number of t terms (taylor series)
        - All t terms are balanced/neutral (they contribute m!n!/m!n! = 1)
        - All z terms are balanced/neutral (they contribute m!n!/m!n! = 1)

        IF YOU ARE ALREADY SUMMING OVER ALL PERMUTATIONS THEN YOU NEED TO USE THE FOLLOWING APPROACH
        FOR H AND Z OTHERWISE EVERYTHING IS BALANCED
        - h and z contribute x!/m!n! where x is the number of UNIQUE t terms that h contracts with


    A single h with no t list is a special case where the prefactor is always 1.
    """
    simplify_flag = False
    a = [0, ] * 11
    print('-'*100)

    # special case, single h
    # if len(t_list) == 1 and t_list[0] == disconnected_eT_z_right_operator_namedtuple(*a):
    #     print(t_list)
    #     print('escaped')
    #     return ''

    numerator = 1
    denominator = 1

    numerator_list, denominator_list = [], []

    # ---------------------------------------------------------------------------------------------------------
    # do the hZ prefactor first

    # this is the Z (1/n!) (which we cancelled our by using the condensed form)
    # if z_right.m > 1:
    #     denominator_list.append(f'{z_right.m}!')
    #     denominator *= math.factorial(int(z_right.m))

    # do the permutations (n choose nk)
    n = z_right.m
    nk = z_right.m_h
    print(f"{n=}  {nk=}")

    choose_result = math.comb(n, nk)

    print(f'hZ choose {choose_result}')
    # the condensed formula is 1/ (nk! * (n - nk)!)

    if nk > 1:
        denominator_list.append(f'{nk}!')
        denominator *= math.factorial(int(nk))

    if (n - nk) > 1:
        denominator_list.append(f'{n - nk}!')
        denominator *= math.factorial(int(n - nk))

    if False:  # apparently we don't do the h order (1/n!)
        if h.m > 1:
            denominator_list.append(f'{h.m}!')
            denominator *= math.factorial(int(h.m))
        if h.n > 1:
            denominator_list.append(f'{h.n}!')
            denominator *= math.factorial(int(h.n))

    print(numerator_list)
    print(denominator_list)
    # ---------------------------------------------------------------------------------------------------------
    # do the V prefactor next

    # account for the number of permutations of all t-amplitudes
    # or said another way the order of the T operator
    t_op_order = len(t_list)

    if t_op_order > 1:
        denominator_list.append(f'{t_op_order}!')
        denominator *= math.factorial(int(t_op_order))

    # do the permutations (n choose nk)
    n = t_op_order

    t_count = {}
    for t in t_list:
        if t.rank not in t_count:
            t_count[t.rank] = 1
        else:
            t_count[t.rank] += 1

    ny = max(t_count.values())

    choose_result = math.comb(n, ny)
    print(f'V choose {choose_result}')
    # the condensed formula is 1/ (nk! * (n - nk)!)

    # if choose_result > 1:
    #     numerator_list.append(f'{choose_result}')
    #     numerator *= choose_result

    # for each t with rank 2 or higher we need to add their 1/n!
    # rank_list = [t.rank for t in t_list if t.rank > 1]

    # for rank in rank_list:
    #     denominator_list.append(f'{rank}!')
    #     denominator *= math.factorial(int(rank))

    # print(numerator_list)
    # print(denominator_list)
    pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None
    # ---------------------------------------------------------------------------------------------------------

    # simplify
    if simplify_flag:
        numerator_list, denominator_list = _simplify_full_cc_python_prefactor(numerator_list, denominator_list)

    # glue the numerator and denominator together
    numerator = '1' if (numerator_list == []) else f"{''.join(numerator_list)}"
    denominator = '1' if (denominator_list == []) else f"{''.join(denominator_list)}"

    if numerator == '1' and denominator == '1':
        return ''
    else:
        return f"\\frac{{{numerator}}}{{{denominator}}}"


def _f_t_h_contributions(t_list, h):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        if isinstance(t, disconnected_t_operator_namedtuple):
            assert 0 == t.m_h == h.n_t[i]
            return_list.append(0)
        else:
            assert t.m_h == h.n_t[i]
            return_list.append(t.m_h)

    return return_list


def _fbar_t_h_contributions(t_list, h):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        if isinstance(t, disconnected_t_operator_namedtuple):
            assert 0 == t.n_h == h.m_t[i]
            return_list.append(0)
        else:
            assert t.n_h == h.m_t[i] >= 1
            return_list.append(t.n_h)

    return return_list


def _f_t_zR_contributions(t_list, z_right):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        assert t.m_r == z_right.n_t[i]
        return_list.append(t.m_r)

    return return_list


def _fbar_t_zR_contributions(t_list, z_right):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        print(t, z_right)
        # assert t.n_r == z_right.m_t[i]
        return_list.append(t.n_r)

    return return_list


def _f_t_zL_contributions(t_list, z_left):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        assert t.m_l == z_left.n_t[i]
        return_list.append(t.m_l)

    return return_list


def _fbar_t_zL_contributions(t_list, z_left):
    """ x """
    return_list = []

    for i, t in enumerate(t_list):
        assert t.n_l == z_left.m_t[i]
        return_list.append(t.n_l)

    return return_list


def _build_eT_term_latex_labels(t_list, offset_dict, color=True, letters=True):
    """ Builds latex code for labeling a `connected_t_operator_namedtuple`."""

    return_list = []

    print("t_list\n", t_list, '\n')
    for t in t_list:
        if t.rank == 0:
            return f"\\mathds{1}"

        upper_indices, lower_indices = '', ''

        if not letters:
            lower_indices += f'{t.n}'
            upper_indices += f'{t.m}'
        else:
            # superscript indices
            if t.m > 0:
                # contract with left z
                a = offset_dict['summation_index']
                indices = r'\magenta{' + z_summation_indices[a:a + t.m_l] + '}'
                upper_indices += indices
                offset_dict['lower_left_z'] += indices
                offset_dict['summation_index'] += t.m_l

                # contract with h
                b = offset_dict['summation_index']
                indicies = r'\blue{' + z_summation_indices[b:b + t.m_h] + '}'
                upper_indices += indicies
                offset_dict['lower_h'] += indicies
                offset_dict['summation_index'] += t.m_h

                # contract with right z
                c = offset_dict['summation_index']
                indicies = r'\magenta{' + z_summation_indices[c:c + t.m_r] + '}'
                upper_indices += indicies
                offset_dict['lower_right_z'] += indicies
                offset_dict['summation_index'] += t.m_r

                # pair with left hand side (LHS)
                u = offset_dict['unlinked_index']
                upper_indices += r'\red{' + z_unlinked_indices[u:u + t.m_lhs] + '}'
                offset_dict['unlinked_index'] += t.m_lhs

            # subscript indices
            if t.n > 0:
                # contract with left z
                a = offset_dict['summation_index']
                indicies = r'\magenta{' + z_summation_indices[a:a + t.n_l] + '}'
                lower_indices += indicies
                offset_dict['upper_left_z'] += indicies
                offset_dict['summation_index'] += t.n_l

                # contract with h
                b = offset_dict['summation_index']
                indicies = r'\blue{' + z_summation_indices[b:b + t.n_h] + '}'
                lower_indices += indicies
                offset_dict['upper_h'] += indicies
                offset_dict['summation_index'] += t.n_h

                # contract with right z
                c = offset_dict['summation_index']
                indicies = r'\magenta{' + z_summation_indices[c:c + t.n_r] + '}'
                lower_indices += indicies
                offset_dict['upper_right_z'] += indicies
                offset_dict['summation_index'] += t.n_r

                # pair with left hand side (LHS)
                u = offset_dict['unlinked_index']
                lower_indices += r'\red{' + z_unlinked_indices[u:u + t.n_lhs] + '}'
                offset_dict['unlinked_index'] += t.n_lhs

        return_list.append(f"{bold_t_latex}^{{{upper_indices}}}_{{{lower_indices}}}")

    return ''.join(return_list)


def _build_eT_hz_term_latex_labels(h, offset_dict, color=True, letters=True):
    """ Builds latex code for labeling a `connected_h_operator_namedtuple`."""

    if h.rank == 0:
        return f"{bold_h_latex}_0"

    upper_indices, lower_indices = '', ''

    if not letters:
        upper_indices = f"{h.m}"
        lower_indices = f"{h.n}"
    else:
        # subscript indices
        if h.n > 0:
            # contract with left t terms
            lower_indices += offset_dict['lower_h']

            # contract with left z

            # contract with right z
            s = offset_dict['summation_index']
            indicies = r'\blue{' + z_summation_indices[s:s + h.n_r] + '}'
            lower_indices += indicies
            offset_dict['upper_right_z'] += indicies
            offset_dict['summation_index'] += h.n_r

            # pair with left hand side (LHS)
            u = offset_dict['unlinked_index']
            lower_indices += r'\red{' + z_unlinked_indices[u:u + h.n_lhs] + '}'
            offset_dict['unlinked_index'] += h.n_lhs

        # superscript indices
        if h.m > 0:
            # contract with right t terms
            upper_indices += offset_dict['upper_h']

            # contract with left z

            # contract with right z
            s = offset_dict['summation_index']
            indicies = r'\blue{' + z_summation_indices[s:s + h.m_r] + '}'
            upper_indices += indicies
            offset_dict['lower_right_z'] += indicies
            offset_dict['summation_index'] += h.m_r

            # pair with left hand side (LHS)
            u = offset_dict['unlinked_index']
            upper_indices += r'\red{' + z_unlinked_indices[u:u + h.m_lhs] + '}'
            offset_dict['unlinked_index'] += h.m_lhs

    return f"{bold_h_latex}^{{{upper_indices}}}_{{{lower_indices}}}"


def _build_eT_right_z_term(h, z_right, offset_dict, color=True, letters=True):
    """ Builds latex code for labeling a `connected_z_right_operator_namedtuple`.

    The `condense_offset` is an optional argument which is needed when creating latex code
    for linked disconnected terms in a condensed format.
    """
    if z_right.rank == 0:
        return f"{bold_z_latex}_0"

    upper_indices, lower_indices = '', ''

    if not letters:
        upper_indices = f"{z_right.m}"
        lower_indices = f"{z_right.n}"
    else:
        # subscript indices
        if z_right.n > 0:
            # contract with left t terms
            # contract with left z
            # contract with h
            lower_indices += offset_dict['lower_right_z']

            # pair with left hand side (LHS)
            u = offset_dict['unlinked_index']
            lower_indices += r'\red{' + z_unlinked_indices[u:u + z_right.n_lhs] + '}'
            offset_dict['unlinked_index'] += z_right.n_lhs

        # superscript indices
        if z_right.m > 0:
            # contract with right t terms
            # contract with left z
            # contract with h
            upper_indices += offset_dict['upper_right_z']

            # pair with left hand side (LHS)
            u = offset_dict['unlinked_index']
            upper_indices += r'\red{' + z_unlinked_indices[u:u + z_right.m_lhs] + '}'
            offset_dict['unlinked_index'] += z_right.m_lhs

    return f"{bold_z_latex}^{{{upper_indices}}}_{{{lower_indices}}}"


def _prepare_third_eTz_latex(
    term_list, split_width=5,
    remove_f_terms=False, print_prefactors=True, suppress_duplicates=True
):
    """Return the latex commands to write the provided terms.

    The `split_width` is the maximum number of terms on 1 horizontal line (in latex) and should
    be changed as needed to fit equations on page.
    If `remove_f_terms` is true terms then terms where nof_fs > 0 will are not written to latex.
    If `print_prefactors` is true then we add the prefactor string generated by `_build_z_latex_prefactor`.
    """
    return_list = []  # store output here

    # for term in term_list:
    #     LHS, t_list, h, z_left, z_right = term[0], term[1], term[2], *term[3]
    #     print(z_right)
    # print('\n\n')

    # for term in term_list:
    #     LHS, t_list, h, z_left, z_right = term[0], term[1], term[2], *term[3]
    #     print(h)

    # prepare all the latex strings
    if False:
        for term in term_list:
            # extract elements of list `term`
            LHS, t_list, h, z_left, z_right = term[0], term[1], term[2], *term[3]
            print(LHS)
            print(t_list)
            print(h)
            print(z_left)
            print(z_right)

        pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

    # prepare all the latex strings
    for term in term_list:
        term_string = ''

        # extract elements of list `term`
        LHS, t_list, h, z_left, z_right = term[0], term[1], term[2], *term[3]

        # if needed add f prefactors
        nof_fs = _f_h_zR_contributions(h, z_right)
        nof_fs += sum(_f_t_h_contributions(t_list, h))
        nof_fs += sum(_f_t_zR_contributions(t_list, z_right))

        if nof_fs > 0:
            if remove_f_terms:
                continue
            term_string += "f" if (nof_fs == 1) else f"f^{{{nof_fs}}}"

        # if needed add fbar prefactors
        nof_fbars = _fbar_h_zR_contributions(h, z_right)
        nof_fbars += sum(_fbar_t_h_contributions(t_list, h))
        nof_fbars += sum(_fbar_t_zR_contributions(t_list, z_right))

        if nof_fbars > 0:
            term_string += "\\bar{f}" if (nof_fbars == 1) else f"\\bar{{f}}^{{{nof_fbars}}}"

        # add any prefactors if they exist
        if print_prefactors:
            term_string += _build_eT_z_latex_prefactor(t_list, h, z_left, z_right)

        # prepare the z terms
        t_offset_dict = {
            'lower_h': '',
            'upper_h': '',
            'lower_left_z': '',
            'upper_left_z': '',
            'lower_right_z': '',
            'upper_right_z': '',
            'unlinked_index': 0,
            'summation_index': 0,
        }

        t_terms = _build_eT_term_latex_labels(t_list, t_offset_dict)

        left_z = ''

        # h_offset_dict = {
        #     't_lower': sum([t.n - t.n_lhs for t in t_list]),
        #     'left_upper': 0,
        #     'summation_index': t_offset_dict['summation_index'],
        #     'unlinked_index': t_offset_dict['unlinked_index']
        # }

        h_term = _build_eT_hz_term_latex_labels(h, t_offset_dict)

        # right_z_offset_dict = {
        #     't_lower': sum([t.m_h for t in t_list]),
        #     't_upper': h_offset_dict['left_upper'] + sum([t.n_h for t in t_list]),
        #     'left_lower': 0,
        #     'left_upper': 0,
        #     'h_lower': h_offset_dict['summation_index'] + h.n_r,
        #     'h_upper': h_offset_dict['summation_index'],
        #     'unlinked_index': h_offset_dict['unlinked_index'] + h.m_lhs + h.n_lhs
        # }

        right_z = _build_eT_right_z_term(h, z_right, t_offset_dict)

        # print('Check t terms:\n', t_terms)
        # pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

        # build the latex code representing this term in the sum
        term_string += t_terms + left_z + h_term + right_z
        print(f"{term_string=}\n")
        pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

        # store the result
        return_list.append(term_string)

    if suppress_duplicates:  # only if we want to replace `return_list` with `unique_list`
        temp_set = set()
        unique_list = []
        for a in return_list:
            if a not in temp_set:
                unique_list.append(a)
                temp_set.add(a)
        return_list = unique_list
    else:
        unique_list = list(set(return_list))
        unique_list.sort()

    log.info(f'\n{tab}Prepared:\n{tab}' + f'\n{tab}'.join([s for s in return_list]))

    # if the line is so short we don't need to split
    if len(return_list) <= split_width+2:
        return f"({' + '.join(return_list)})"

    # numbers = list(range(0, len(return_list)))
    # number_list = []
    split_equation_list = []
    # print('a', len(return_list) // split_width)

    for i in range(0, len(return_list) // split_width):
        split_equation_list.append(' + '.join(return_list[i*split_width:(i+1)*split_width]))
        # number_list.append(numbers[i*split_width:(i+1)*split_width])

    # make sure we pickup the last few terms
    last_few_terms = len(return_list) % split_width
    if last_few_terms != 0:
        split_equation_list.append(' + '.join(return_list[-last_few_terms:]))
        # number_list.append(numbers[-last_few_terms:])

    # join the lists with the equation splitting string
    splitting_string = r'\\  &+  % split long equation'
    final_string = f"\n{tab}{splitting_string}\n".join(split_equation_list)

    # and we're done!
    return f"\n{final_string}\n"

# -------------------------------------------------------------------------------- #


def _prepare_eTz_z_terms(Z_left, Z_right, zhz_debug=False):
    """ Factor out z preparation from `_filter_out_valid_eTz_terms` """

    # H*Z terms, straightforward
    if Z_left is None:
        header_log.info("Z is on the right")
        z_left_terms = [general_operator_namedtuple(None, 0, 0, 0), ]
        z_right_terms = Z_right.operator_list
        assert isinstance(z_right_terms, list) and isinstance(z_right_terms[0], general_operator_namedtuple)

    # Z*H terms, straightforward
    elif Z_right is None:
        header_log.info("Z is on the left")
        z_left_terms = Z_left.operator_list
        z_right_terms = [general_operator_namedtuple(None, 0, 0, 0), ]
        # z_right_terms = Z_left.operator_list
        assert isinstance(z_left_terms, list) and isinstance(z_left_terms[0], general_operator_namedtuple)

        # valid_lower_perms = [list(it.dropwhile(lambda y: y == 0, x)) for x in unique_permutations if (maximum >= sum(x))]
        # valid_lower_perms[valid_lower_perms.index([])] = [0]

    # Z*H*Z terms, most complicated
    else:
        zhz_debug = True
        header_log.info("Z is on both sides")
        z_left_terms = Z_left.operator_list
        z_right_terms = Z_right.operator_list
        assert isinstance(z_right_terms, list) and isinstance(z_right_terms[0], general_operator_namedtuple)
        assert isinstance(z_left_terms, list) and isinstance(z_left_terms[0], general_operator_namedtuple)

    all_z_permutations = [(z_left, z_right) for z_left, z_right in it.product(z_left_terms, z_right_terms)]

    if zhz_debug or False:  # debug prints
        # print all possible pairings
        for a in all_z_permutations:
            old_print_wrapper('Z PAIRING', a)

        # we may not need the unique permutations... unclear at this moment
        if zhz_debug or False:
            unique_z_permutation_list = sorted(list(set(all_z_permutations)))
            for a in unique_z_permutation_list:
                old_print_wrapper('Z TERM1', a)

    return all_z_permutations


def _prepare_eTz_T_terms(eT_series_term):
    """ Factor out T preparation from `_filter_out_valid_eTz_terms`.

    find out what term (in the taylor expansion of e^T) `T_series_term` represents
    set a boolean flag, and wrap the lower order terms in lists so that they have the same
    structure as the s_n case (a list of lists of `general_operator_namedtuple`s)
    """

    # T^0 operator is simply 1 in this case
    if isinstance(eT_series_term, general_operator_namedtuple):
        subheader_log.info("PROCESSING T^0")
        order = 0
        eT_series_term = [[eT_series_term, ], ]  # wrap in a list of lists

    # T^1 operator, straightforward
    if isinstance(eT_series_term, list) and isinstance(eT_series_term[0], general_operator_namedtuple):
        subheader_log.info("PROCESSING T^1")
        order = 1
        eT_series_term = [[term, ] for term in eT_series_term]  # wrap in a list

    # T^n operator, most complicated
    elif isinstance(eT_series_term, list) and isinstance(eT_series_term[0], list) and len(eT_series_term[0]) > 0:
        subheader_log.info("PROCESSING T^n")
        order = 'n'
        # no wrapping necessary

    # this shouldn't happen
    else:
        raise Exception(
            'Check `generate_eT_taylor_expansion` '
            'and see if the return value '
            'propagates correctly to this location.'
        )

    return eT_series_term, order


def _filter_out_valid_eTz_terms(LHS, eT, H, Z_left, Z_right, total_list, zhz_debug=False):
    """ fill up the `term_list` and `total_list` for the Z^n term
    first we find out what term (in the taylor expansion of e^Z) `z_series_term` represents
    set a boolean flag, and wrap the lower order terms in lists so that they have the same
    structure as the z_n case (a list of lists of `general_operator_namedtuple`s)
    """

    all_z_permutations = _prepare_eTz_z_terms(Z_left, Z_right, zhz_debug)
    eT, eT_order = _prepare_eTz_T_terms(eT)

    # next we process the z operators inside z_term_list
    for h in H.operator_list:

        if True:  # debug
            nof_terms = sum([len(x) for x in eT])
            subheader_log.debug(f"Checking the T^{eT_order} term:")

            if eT_order == 0:
                log.debug(f'\n{tab}'.join([
                    '',
                    f'{"LHS":<12s}{LHS}',
                    f'{"eT":<12s}{eT}',
                    f'{"Z_left":<12s}None',
                    f'{"h":<12s}{h}',
                    f'{"Z_right":<12s}None',
                ]))

            elif nof_terms < 60:
                spread_string = f'\n{tab}{tab}{tab}{tab}'.join([str(x) for x in eT])

                log.debug(f'\n{tab}'.join([
                    '',
                    f'{"LHS":<12s}{LHS}',
                    f'{"eT":<12s}{spread_string}',
                    f'{"Z_left":<12s}None',
                    f'{"h":<12s}{h}',
                    f'{"Z_right":<12s}None',
                ]))
            else:
                log.debug(f'\n{tab}'.join([
                    '',
                    f'{"LHS":<12s}{LHS}',
                    f'number of s terms: {nof_terms}',
                    f'{"Z_left":<12s}None',
                    f'{"h":<12s}{h}',
                    f'{"Z_right":<12s}None',
                ]))

        # valid pairings of s operators given a specific `LHS` and `h`
        valid_permutations = _generate_valid_eT_z_n_operator_permutations(LHS, eT, h, all_z_permutations)

        # if no valid operators continue to the next h
        if valid_permutations == []:
            continue

        if zhz_debug or True:  # debug prints
            for pair in valid_permutations:
                old_print_wrapper('VALID TERM', LHS, pair[0], h, pair[1], pair[2])
                print('VALID TERM', LHS, pair[0], h, pair[1], pair[2])

        log_conf.setLevelDebug(log)
        # we need to generate all possible combinations of
        # each z with the LHS, eT, h operators and the other z
        eT_connection_permutations = _generate_all_o_eT_h_z_connection_permutations(LHS, h, valid_permutations)

        if zhz_debug or True:  # debug prints
            for p in eT_connection_permutations:
                old_print_wrapper('CONNECTED TERMS', LHS, p[0], h, p[1])
                print('CONNECTED TERMS', LHS, p[0], h, p[1])

        # pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None
        # continue

        # we need to remove duplicate permutations
        unique_eT_permutations = _remove_duplicate_eT_z_permutations(LHS, h, eT_connection_permutations)
        # unique_eT_permutations = eT_connection_permutations
        log_conf.setLevelInfo(log)

        # assert list(eT_connection_permutations) != []

        if zhz_debug or True:  # debug prints
            for T, z in unique_eT_permutations:
                old_print_wrapper('UNIQUE TERMS', LHS, eT, h, z)
                print('UNIQUE TERMS', LHS, T, h, z)

        # generate all the explicit connections
        # this also removes all invalid terms
        labeled_permutations = _generate_explicit_eT_z_connections(LHS, h, unique_eT_permutations)

        # for i, a in enumerate(labeled_permutations):
        #     print(
        #         '-'*20 + f'labeled {i}' + '-'*20,
        #         a[0],
        #         a[1],
        #         a[2],
        #         a[3],
        #         sep='\n'
        #     )

        # we record
        for term in labeled_permutations:
            log.debug(f"{term=}")
            if term[2] != set():
                # if it is not an empty set
                total_list.append(term)
            else:
                old_print_wrapper('exit?')
                sys.exit(0)

        # for i, a in enumerate(total_list):
        #     if i < len(total_list) - 1:
        #         continue
        #     print(
        #         '-'*20 + f'total_list {i}' + '-'*20,
        #         a[0],
        #         a[1],
        #         a[2],
        #         a[3],
        #         sep='\n'
        #     )

    return


def _build_third_eTz_term(LHS, eT_taylor_expansion, H, Z, remove_f_terms=False):
    """
    LHS * (t*t*t) * H * Z

    This one basically needs to be like the t term stuff EXCEPT:
        - there is a single z term
        - it is always on the right side
        - always bond to projection operator in opposite dimension (^i _i)
    """

    valid_term_list = []   # store all valid Omega * (t*t*...t) * h * Z  terms here

    """ First we want to generate a list of valid terms.
    We start with the list of lists `eT_taylor_expansion` which is processed by `_filter_out_valid_eT_terms`.
    This function identifies valid pairings AND places those pairings in the `valid_term_list`.
    Specifically we replace the `general_operator_namedtuple`s with `connected_namedtuple`s and/or
    `disconnected_namedtuple`s.
    """
    for count, eT_series_term in enumerate(eT_taylor_expansion):

        # _filter_out_valid_eT_terms(LHS, eT_series_term, H, Z, valid_term_list, remove_f_terms=remove_f_terms)

        log.setLevel('DEBUG')
        # generate all valid combinations
        _filter_out_valid_eTz_terms(LHS, eT_series_term, H, None, Z, valid_term_list)
        log.setLevel('INFO')

    if False:
        print('\n\n\n')
        for i, a in enumerate(valid_term_list):
            print(f"{i+1:>4d}", a)
        pdb.set_trace() if inspect.stack()[-1].filename == 'driver.py' else None

    if valid_term_list == []:
        return ""

    return _prepare_third_eTz_latex(valid_term_list, remove_f_terms=remove_f_terms)


# -------------------------------------------------------------------------------- #

def _generate_eT_z_symmetric_latex_equations(LHS, eT_taylor_expansion, H, Z, only_ground_state=True, remove_f_terms=False):
    """Return a string containing latex code to be placed into a .tex file.
    For a given set of input arguments: (`LHS`, `H`, `Z`) we generate
    all possible and valid CC terms. Note that:
        - `LHS` is an `LHS_namedtuple` object
        - `H` is a `hamiltonian_namedtuple` object
        - `Z` is a `z_operator_namedtuple` object
        - `eT_taylor_expansion` is one of :
            - a single `general_operator_namedtuple`
            - a list of `general_operator_namedtuple`s
            - a list of lists of `general_operator_namedtuple`s

    One possible input could be:
        - `LHS` is the creation operator d
        - `H` is a Hamiltonian of rank two
        - `Z` is the Z operator
        - `eT_taylor_expansion` is the S^1 Taylor expansion term
    """
    return_string = ""

    # the first H term
    return_string += _build_first_z_term(LHS)

    # the second (subtraction) term
    if not only_ground_state:  # If we are acting on the vaccum state then these terms don't exist
        raise Exception(
            "The excited state second eTZH terms are not implemented.\n"
            "To properly implement this Z term we need to write a new function `_build_second_eTz_term`"
            "Which loops over `eT_taylor_expansion` in the same way as `_build_third_eTz_term`"
            "Do not remove this exception unless you have fully implemented the new function `_build_second_eTz_term`"
        )
        return_string += r'\\&-\Big(' + _build_second_z_term(LHS, H, Z, remove_f_terms) + r'\Big)'

    # the third (addition) term
    return_string += r'\\&+\sum\Big(' + _build_third_eTz_term(LHS, eT_taylor_expansion, H, Z, remove_f_terms) + r'\Big)(1-\delta_{cb})'

    # the fourth (subtraction) term
    if not only_ground_state:  # If we are acting on the vaccum state then these terms don't exist
        raise Exception(
            "The excited state second eTZHZ terms are not implemented.\n"
            "To properly implement this Z term we need to write a new function `_build_fourth_eTz_term`"
            "Which loops over `eT_taylor_expansion` in the same way as `_build_third_eTz_term`"
            "Do not remove this exception unless you have fully implemented the new function `_build_fourth_eTz_term`"
        )
        return_string += r'\\&-\sum\Big(' + _build_fourth_z_term(LHS, H, Z, remove_f_terms) + r'\Big)(1-\delta_{db})'

    if only_ground_state:  # If we are acting on the vacuum state then we add these extra terms
        temporary_string = r"\text{all permutations of }\dv{\hat{t}_{\gamma}}{\tau}\hat{z}"
        return_string += r'\\&-i\sum\Big(' + _build_fifth_z_term(LHS, Z) + r'\Big)'

    # remove all empty ^{}/_{} terms that are no longer needed
    return return_string.replace("^{}", "").replace("_{}", "")


def generate_eT_z_t_symmetric_latex(truncations, only_ground_state=True, remove_f_terms=False, path="./generated_latex.tex"):
    """Generates and saves to a file the latex equations for full CC expansion."""

    assert len(truncations) == 5, "truncations argument needs to be tuple of five integers!!"
    maximum_h_rank, maximum_cc_rank, maximum_T_rank, eT_taylor_max_order, omega_max_order = truncations

    master_omega = generate_omega_operator(maximum_cc_rank, omega_max_order)
    raw_H = generate_full_cc_hamiltonian_operator(maximum_h_rank)
    Z = generate_z_operator(maximum_cc_rank, only_ground_state)
    eT_taylor_expansion = generate_eT_taylor_expansion(maximum_T_rank, eT_taylor_max_order)

    """ omega and e^T only generate annihilation operators
        H and Z both generate creation operators
        therefore `rank(e^T)` is restricted to `rank(H) + rank(Z)`
    """
    # assert maximum_eT_rank <= maximum_h_rank + maximum_cc_rank, 'ranks are wrong'

    # aug 4th songhao says this is because of theory
    pruned_list = [term for term in raw_H.operator_list if (term.rank < 3) or (term.m == 0)]
    H = hamiltonian_namedtuple(raw_H.maximum_rank, pruned_list)

    latex_code = ""  # store result in here

    rank_name_list = [
        "0 order", "LINEAR", "QUADRATIC", "CUBIC", "QUARTIC", "QUINTIC", "SEXTIC", "SEPTIC", "OCTIC"
    ]

    for i, omega_term in enumerate(master_omega.operator_list):

        # for debugging purposes
        # if you only want to generate the linear terms for example; change the False to True
        if False and omega_term.rank not in [1, ]:
            continue

        # for the new ansatz v5 we only print the annihilation operator projections
        if omega_term.m > 0:
            continue

        rank_name = rank_name_list[omega_term.rank]

        if omega_term.rank > master_omega.operator_list[i-1].rank:
            # latex_code += '\\newpage\n' if omega_term.rank >= 2 else ''
            latex_code += f'\\paragraph{{{rank_name.capitalize()} Equations}}\n\n'
        else:
            latex_code += r'\vspace{2cm}'

        def _generate_t_lhs(omega):

            upper_label = summation_indices[0:omega.n]
            lower_label = summation_indices[omega.n:omega.rank]
            lower_label += r'\gamma' if lower_label == "" else r',\gamma'

            t_term_latex = f"\\hat{{{bold_t_latex}}}^{{{upper_label}}}_{{{lower_label}}}"

            # the t term we are taking the derivative of
            derivative_latex = rf'i\dv{{{t_term_latex}}}{{\tau}}'

            return derivative_latex

        def _wrap_t_latex(omega, lhs):
            """ Latex commands to wrap around the generated terms `lhs`
            so that the *.tex file compiles correctly.
            """
            omega_string = ""
            for i, char in enumerate(omega.name):
                if char == "d":
                    omega_string += f'\\up{{{summation_indices[i]}}}'
                elif char == "b":
                    omega_string += f'\\down{{{summation_indices[i]}}}'

            omega_string = "1" if omega_string == "" else omega_string

            g_upper_label = f"{summation_indices[0:omega.n]}" if omega.n > 0 else ""
            g_lower_label = f"{summation_indices[omega.n:omega.rank]}" if omega.m > 0 else ""
            g_lower_label += r'\gamma\gamma' if g_lower_label == "" else r', \gamma\gamma'
            g_string = f"\\hat{{G}}^{{{g_upper_label}}}_{{{g_lower_label}}}"

            return (
                '\\begin{equation}\n'
                f'{tab}\\hat{{\\Omega}} = {omega_string}\n'
                r'\qquad\qquad'
                f"\n{tab}{lhs} = {g_string}"
                "\n"
                r'\end{equation}'
                '\n\n'
            )

        # generate latex for t terms
        if True:
            # generate the i(dt/dtau + t*epsilon) latex
            lhs_string = _generate_t_lhs(omega_term)

            # where we do all the work of generating the latex
            # header for the sub section
            latex_code += '%\n%\n%\n%\n%\n\n'
            latex_code += _wrap_t_latex(omega_term, lhs_string)

        def _wrap_z_align_environment(lhs, eqns):
            """ Latex commands to wrap around the generated terms `lhs` and `eqns`
            so that the *.tex file compiles correctly.
            """
            string = (
                '\\begin{align}\\begin{split}\n'
                r'LHS &='
                '\n'
                f"{tab}{lhs}\n"
                r'\\ RHS &='
                '\n%\n%\n'
                f'{eqns}\n'
                r'\end{split}\end{align}'
                '\n\n'
            )
            return string

        def _generate_z_lhs(omega):
            """ quick fix """
            upper_label = summation_indices[0:omega.rank]
            z_term_latex = f"\\hat{{{bold_z_latex}}}^{{{upper_label}}}_{{\\gamma}}"

            # the t term we are taking the derivative of
            derivative_latex = rf'i\Big(\dv{{{z_term_latex}}}{{\tau}}\Big)'
            return derivative_latex

        # generate latex for z terms
        # the omega term is the LHS
        if True:
            # generate the i(dt/dtau + t*epsilon) latex
            lhs_string = _generate_z_lhs(omega_term)

            # where we do all the work of generating the latex
            equations_string = _generate_eT_z_symmetric_latex_equations(
                omega_term, eT_taylor_expansion, H, Z, only_ground_state, remove_f_terms
            )

            # header for the sub section
            latex_code += '%\n%\n%\n%\n%\n\n'
            latex_code += _wrap_z_align_environment(lhs_string, equations_string)

    # write the latex to file
    if only_ground_state:
        # use the predefined header in `reference_latex_headers.py`
        header = headers.ground_state_z_t_symmetric_latex_header
    else:
        # use the predefined header in `reference_latex_headers.py`
        header = headers.full_z_t_symmetric_latex_header

    header += '\\textbf{Note that all terms with a $f$ prefactor have been removed}\n' if remove_f_terms else ''

    # write the new header with latex code attached
    with open(path, 'w') as fp:
        fp.write(header + latex_code + r'\end{document}')

    return
